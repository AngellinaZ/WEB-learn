1.let 和 const 命令
  for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
      for (let i = 0; i < 3; i++) {
        let i = 'abc';
        console.log(i);
      }
      // abc
      // abc
      // abc
  上面代码正确运行，输出了3次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。
  
  let 特点：
      1).不存在变量提升，它所声明的变量一定要在声明后使用
      
      2).暂时性死区(TDZ)，只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。
      'ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。'
      
      3). 块级作用域与函数声明
          ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。
          ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
        --考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。
        // 函数声明语句
        {
          let a = 'secret';
          function f() {
            return a;
          }
        }
        // 函数表达式
        {
          let a = 'secret';
          let f = function () {
            return a;
          };
        }
        
        4).do表达式 : 返回值
        let x = do {
          let t = f();
          t * t + 1;
        }; //变量x会得到整个块级作用域的返回值。
      
   const常量 特点：
       1).const声明一个 只读 的常量。一旦声明，常量的值就不能改变。
       2).const一旦声明变量，就必须立即初始化，不能留到以后赋值。
       3).只在声明所在的块级作用域内有效。
       4).const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
       5).与let一样不可重复声明。
       
2.变量的解构赋值
    ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。
