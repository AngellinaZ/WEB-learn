<!DOCTYPE html>
<html>
<head>
	<title></title>
</head>
<body>
	<p>4种模式下，参数this的差异</p>
	<div>
		<ul>
			<li>
				<h3>全局范围内, this</h3>
				<p>指向全局对象</p>
			</li>
			<li>
				<h3>函数调用模式, foo()</h3>
				<p>this: 全局对象</p>
				<p>当一个函数并非一个对象的属性时, 称之为函数。</p>
				<p>方法不能通过内部函数来共同访问对象：通过在外部定义var that = this, 解决内部函数的this的指向</p>
			</li>
			<li>
				<h3>方法调用模式, test.foo()</h3>
				<p>当一个方法被调用时, this被绑定到该对象test </p>
				<p>当一个函数被保存为obj的一个属性时, 称之为方法。</p>
				<p>方法可以使用this访问自己所属的对象, 它能从对象中取值或对对象进行修改</p>
			</li>
			<li>
				<h3>构造器调用模式, var test = new foo();</h3>
				<p>JS是一门基于原型继承的语言, 对象可以直接从其他对象继承属性</p>
				<p>new xxx() ==> 创建一个连接到该函数的prototype成员的新对象，同时this绑定到新对象上</p>
			</li>
			<li>
				<h3>Apply调用模式</h3>
				<p>允许选择this值, apply(绑定给this的值, 一个参数数组)</p>
			</li>
		</ul>
	</div>

	<script type="text/javascript">
		var o = {
			a: 10,
			b: {
				fn: function () {
					console.log(this);
					console.log(this.a);	 
				}
			}
		}
		o.b.fn();   // 对象b, undefined ---方法fn所在的对象是b, b内不存在a变量
		o.b.a = 12; // 给对象b添加属性a, 值为12
		o.b.fn();   // 对象b, 12 ---方法fn所在的对象是b, b内存在a变量, a: 12
		var j = o.b.fn; //函数
		j();        // window, undefind ---函数调用模式, 函数的this指向全局，全局下并没有a


		//给o增加double方法
		o.double = function () {
			var that = this; 

			var helper = function () {
				that.a = that.a + 4;
			};

			helper(); //函数的形式调用
		}
		o.double();
		console.log(o.a); //14
		
		
	        //构造函数调用模式
		function a() {
			this.abc = 'abc';
		}
		var test = new a(); 
		/*	=> new a(): 开辟内存空间(object类型), 构造器中的this被绑定在此空间上(新创建的对象)
			{
				constructor: a 本身,
				__proto__: a.prototype (默认为Object.prototype),
				abc: 'abc'
			}
		==> 返回一个引用值并赋值给test
		*/
		console.log(test.abc); //abc
	</script>
</body>
</html>
