<!DOCTYPE html>
<html>
<head>
	<title>构造函数</title>
</head>
<body>
	<div>
		<ul>
			<li>what？： 通过new + 关键字方式调用的函数</li>
			<li>this指向：指向新创建的对象Object</li>	
			<li>新创建对象的prototype指向构造函数的prototype</li>	
		</ul>
	</div>

	<script type="text/javascript">
	    //构造函数调用模式
		function a() {
			this.abc = 'abc';
		}
		var test = new a(); 
		/*	=> new a(): 开辟内存空间(object类型), 构造器中的this被绑定在此空间上(新创建的对象)
			{
				constructor: a 本身,
				__proto__: a.prototype (默认为Object.prototype),
				abc: 'abc'
			}
		==> 返回一个引用值并赋值给test
		*/
		console.log(test.abc); //abc
		
		
		/*显式的 return 表达式将会影响返回结果，但仅限于返回的是一个对象。*/
		//返回新创建的对象
		function Bar() {
			return 2;
		}
		new Bar(); // 返回新创建的对象Bar{},而不是数字的字面量2, 因此 new Bar().constructor === Bar
		
		/*但是如果返回的是数字对象，结果就不同了，如下所示
		function Bar() {
			return new Number(2);
		}
		new Bar().constructor === Number */
		
		//返回函数的对象
		function Test() {
			this.value = 2;

			return {
				foo: 1
			};
		}
		new Test(); // 是函数返回的对象, 而不是通过new关键字新创建的对象 Object {foo: 1}
	</script>
</body>
</html>
