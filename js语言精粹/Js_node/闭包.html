<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>闭包</title>
</head>
<body>
	<p>优点: 函数内部可以访问定义它们的外部函数的参数和变量(除了this, arguments)</p>
	<p>内部函数拥有比他的外部函数更长的生命周期</p>

	<a href="#" name="test">点击我0...</a><br> 
	<a href="#" name="test">点击我1...</a><br> 
	<a href="#" name="test">点击我2...</a><br> 

	<script type="text/javascript">
		/*
			* for循环，开辟了一个大的存储空间，其中 变量i：0 --> nodes.length
			* 存储空间内开辟了nodes.length个fun小空间，fun内的i指向最外层的变量i
		*/
		var add_the_handlers = function(nodes){
		    for(var i = 0; i < nodes.length; i++) {
		        nodes[i].onclick = function(e){ 
		            console.log(i); //3, 3, 3
		        };
		    }

		    /*使用let定义块级作用域, 每个i只在自己的块级作用域内有效*/
		    // for(let i = 0; i < nodes.length; i++) {
		    //     nodes[i].onclick = function(e){ 
		    //         console.log(i); //0, 1, 2
		    //     };
		    // }
		};


		var add_the_handlers1 = function(nodes){
		    for(var i = 0; i < nodes.length; i++) {
		        nodes[i].onclick = function(i){
		        	console.log(nodes[i].innerHTML)  //为什么直接执行？？？
		            return function(e){  
		            	//为什么点击后执行？--函数的引用，赋值click事件句柄,只有点击的时候才会触发句柄 从而执行函数
		            	console.log(this)
		                console.log(i); 
		            };
		        }(i); // 自执行
		    }
		};

		var objs = document.getElementsByName("test");
		// add_the_handlers(objs);	
		add_the_handlers1(objs);
		
	</script>
</body>
</html>